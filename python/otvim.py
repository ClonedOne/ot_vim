from enum import Enum

class OperationType(Enum):
    INSERT = 1
    DELETE = 2


class OTVim:
    def __init__(self, vim, autocmds=lambda: None):
        self._vim = vim
        self._autocmds = autocmds


    def start(self):
        self._buffer = self._vim.current.buffer
        self._autocmds()


    def stop(self):
        pass


    def check_buffer(self):
        #  print("Check buffer test")
        #  print(list(self._vim.current.window.cursor))
        print(len(self._vim.current.buffer))



    def find_difs(b1, b2):
        """ Finds the position of the change in the buffer and returns the change

        Returns a tuple (X (ROW), Y (COLUMN), CHAR, OPERATION)
        """

    #     save the current position of the cursor and its line length
        cursor_y = cursor[0] - 1
        cursor_x = cursor[1]
        cur_line_len = len(b2[cursor_y])

    #     a line was added
        if len(b1) < len(b2):

    #         if it is an insert of a newline then the length of
    #         the new line will be 0
            if cur_line_len == 0:
                return (cursor_y, 0, '\n', OperationType.INSERT)

    #         a new line generated by a line paste operation will still
    #         have the cursor in position 0 but will have length > 0
            elif cursor_x == 0 and len(b2[cursor_y]) > 0:
            ## TODO: HANDLE ENTIRE STRING
                return (cursor_y, 0, b2[cursor_y], OperationType.INSERT)

            else:
                print("ERROR: INSERT NOT HANDLED")


    #     a line was removed
        elif len(b2) < len(b1):

    #         if this is a single char delete operation that removed the
    #         newline character, the cursor_x will be equal
    #         to the length of the line above in the old buffer.
    #         The length of the above line in the new buffer will also be longer
            if cursor_x == len(b1[cursor_y]) and len(b2[cursor_y]) > len(b1[cursor_y]):
                return (cursor_y + 1, 0, '\n', OperationType.DELETE)

    #         if the removal of the line is due to a line delete operation
    #         the cursor will be at position 0 on the line above.
    #         The length of the above line in the new buffer will not be changed
            elif cursor_x == 0 and len(b2[cursor_y]) == len(b1[cursor_y]):
            ## TODO: HANDLE ENTIRE STRING
                return (cursor_y + 1, 0, b1[cursor_y + 1], OperationType.DELETE)

            else:
                print("ERROR: DELETE NOT HANDLED")

    #     the operation is on the same line
        else:

    #         transform the line into position-preserving sets and perform
    #         set subraction to find differences
    #          - old_buffer \ new_buffer in case of delete
    #          - new_buffer \ old_buffer in case of insert

            s1 = set([(cursor_y, pos, b1[cursor_y][pos]) for pos in range(len(b1[cursor_y]))])
            s2 = set([(cursor_y, pos, b2[cursor_y][pos]) for pos in range(len(b2[cursor_y]))])

    #         insert or change operation
            if len(b1[cursor_y]) <= len(b2[cursor_y]):
                return [(elem[0], elem[1], elem[2], OperationType.INSERT) for elem in s2 - s1]

    #         delete operation
            else:
                return [(elem[0], elem[1], elem[2], OperationType.DELETE) for elem in s1 - s2]

